// backend/server.js
const express = require('express');
const cors = // backend/server.js
const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const mysql = require('mysql2/promise');
require('dotenv').config();

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(morgan('dev'));
app.use(express.json());

// Configuração do Banco de Dados
const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'matematica_facil',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
};

const pool = mysql.createPool(dbConfig);

// Middleware de Autenticação
const authenticateToken = (requiredRole = null) => {
    return async (req, res, next) => {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];

        if (!token) {
            return res.status(401).json({ error: 'Token não fornecido' });
        }

        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret_key');
            
            // Buscar usuário no banco
            const [users] = await pool.execute(
                'SELECT * FROM usuarios WHERE id = ? AND ativo = true',
                [decoded.userId]
            );

            if (users.length === 0) {
                return res.status(401).json({ error: 'Usuário não encontrado' });
            }

            req.user = users[0];

            // Verificar role se necessário
            if (requiredRole && req.user.tipo !== requiredRole) {
                return res.status(403).json({ error: 'Acesso negado' });
            }

            next();
        } catch (error) {
            return res.status(403).json({ error: 'Token inválido' });
        }
    };
};

// Rotas de Autenticação
app.post('/api/auth/register', async (req, res) => {
    try {
        const { nome, email, senha } = req.body;

        // Verificar se email já existe
        const [existingUsers] = await pool.execute(
            'SELECT id FROM usuarios WHERE email = ?',
            [email]
        );

        if (existingUsers.length > 0) {
            return res.status(400).json({ error: 'Email já cadastrado' });
        }

        // Hash da senha
        const hashedPassword = await bcrypt.hash(senha, 10);

        // Inserir usuário
        const [result] = await pool.execute(
            'INSERT INTO usuarios (nome, email, senha, tipo) VALUES (?, ?, ?, "aluno")',
            [nome, email, hashedPassword]
        );

        // Gerar token JWT
        const token = jwt.sign(
            { userId: result.insertId, email },
            process.env.JWT_SECRET || 'secret_key',
            { expiresIn: '24h' }
        );

        res.status(201).json({
            message: 'Usuário cadastrado com sucesso',
            token,
            user: {
                id: result.insertId,
                nome,
                email,
                tipo: 'aluno'
            }
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao cadastrar usuário' });
    }
});

app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, senha } = req.body;

        // Buscar usuário
        const [users] = await pool.execute(
            'SELECT * FROM usuarios WHERE email = ? AND ativo = true',
            [email]
        );

        if (users.length === 0) {
            return res.status(401).json({ error: 'Credenciais inválidas' });
        }

        const user = users[0];

        // Verificar senha
        const validPassword = await bcrypt.compare(senha, user.senha);
        if (!validPassword) {
            return res.status(401).json({ error: 'Credenciais inválidas' });
        }

        // Gerar token JWT
        const token = jwt.sign(
            { userId: user.id, email: user.email },
            process.env.JWT_SECRET || 'secret_key',
            { expiresIn: '24h' }
        );

        res.json({
            token,
            user: {
                id: user.id,
                nome: user.nome,
                email: user.email,
                tipo: user.tipo,
                foto_url: user.foto_url
            }
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao fazer login' });
    }
});

// Rotas de Cursos (Públicas)
app.get('/api/cursos', async (req, res) => {
    try {
        const [cursos] = await pool.execute(
            'SELECT id, titulo, descricao, valor, imagem_url FROM cursos WHERE ativo = true ORDER BY created_at DESC'
        );
        res.json(cursos);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao buscar cursos' });
    }
});

app.get('/api/cursos/:id', async (req, res) => {
    try {
        const [cursos] = await pool.execute(
            'SELECT id, titulo, descricao, valor, imagem_url FROM cursos WHERE id = ? AND ativo = true',
            [req.params.id]
        );

        if (cursos.length === 0) {
            return res.status(404).json({ error: 'Curso não encontrado' });
        }

        res.json(cursos[0]);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao buscar curso' });
    }
});

// Rotas de Aulas Demo
app.get('/api/aulas-demo', async (req, res) => {
    try {
        const [aulas] = await pool.execute(
            'SELECT id, titulo, descricao, video_url, duracao_minutos FROM aulas_demo WHERE ativo = true ORDER BY ordem'
        );
        res.json(aulas);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao buscar aulas demo' });
    }
});

app.post('/api/leads', async (req, res) => {
    try {
        const { nome, email } = req.body;

        // Verificar se email já existe
        const [existingLeads] = await pool.execute(
            'SELECT id FROM leads WHERE email = ?',
            [email]
        );

        if (existingLeads.length > 0) {
            return res.status(200).json({ message: 'Lead já cadastrado' });
        }

        // Inserir lead
        await pool.execute(
            'INSERT INTO leads (nome, email, origem) VALUES (?, ?, "aula_demo")',
            [nome, email]
        );

        res.status(201).json({ message: 'Lead cadastrado com sucesso' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao cadastrar lead' });
    }
});

// Rotas do Painel Administrativo (Protegidas)
app.get('/api/admin/cursos', authenticateToken('admin'), async (req, res) => {
    try {
        const [cursos] = await pool.execute(
            'SELECT * FROM cursos ORDER BY created_at DESC'
        );
        res.json(cursos);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao buscar cursos' });
    }
});

app.post('/api/admin/cursos', authenticateToken('admin'), async (req, res) => {
    try {
        const { titulo, descricao, valor, link_acesso, senha_acesso, imagem_url } = req.body;

        // Gerar hash da senha de acesso
        const hashedPassword = await bcrypt.hash(senha_acesso, 10);

        const [result] = await pool.execute(
            'INSERT INTO cursos (titulo, descricao, valor, link_acesso, senha_acesso, imagem_url) VALUES (?, ?, ?, ?, ?, ?)',
            [titulo, descricao, valor, link_acesso, hashedPassword, imagem_url]
        );

        res.status(201).json({
            message: 'Curso criado com sucesso',
            id: result.insertId
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao criar curso' });
    }
});

app.put('/api/admin/cursos/:id', authenticateToken('admin'), async (req, res) => {
    try {
        const { titulo, descricao, valor, link_acesso, senha_acesso, imagem_url, ativo } = req.body;
        const cursoId = req.params.id;

        let updateFields = [];
        let values = [];

        if (titulo) { updateFields.push('titulo = ?'); values.push(titulo); }
        if (descricao) { updateFields.push('descricao = ?'); values.push(descricao); }
        if (valor) { updateFields.push('valor = ?'); values.push(valor); }
        if (link_acesso) { updateFields.push('link_acesso = ?'); values.push(link_acesso); }
        if (senha_acesso) {
            const hashedPassword = await bcrypt.hash(senha_acesso, 10);
            updateFields.push('senha_acesso = ?');
            values.push(hashedPassword);
        }
        if (imagem_url) { updateFields.push('imagem_url = ?'); values.push(imagem_url); }
        if (ativo !== undefined) { updateFields.push('ativo = ?'); values.push(ativo); }

        values.push(cursoId);

        if (updateFields.length === 0) {
            return res.status(400).json({ error: 'Nenhum campo para atualizar' });
        }

        const query = `UPDATE cursos SET ${updateFields.join(', ')} WHERE id = ?`;
        
        await pool.execute(query, values);

        res.json({ message: 'Curso atualizado com sucesso' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao atualizar curso' });
    }
});

app.delete('/api/admin/cursos/:id', authenticateToken('admin'), async (req, res) => {
    try {
        await pool.execute('DELETE FROM cursos WHERE id = ?', [req.params.id]);
        res.json({ message: 'Curso excluído com sucesso' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao excluir curso' });
    }
});

// Relatórios Administrativos
app.get('/api/admin/relatorios/alunos', authenticateToken('admin'), async (req, res) => {
    try {
        const [alunos] = await pool.execute(`
            SELECT 
                u.id,
                u.nome,
                u.email,
                COUNT(DISTINCT c.id) as total_cursos,
                COUNT(DISTINCT comp.id) as total_compras,
                SUM(CASE WHEN comp.status = 'aprovado' THEN comp.valor ELSE 0 END) as total_gasto,
                MAX(comp.created_at) as ultima_compra
            FROM usuarios u
            LEFT JOIN compras comp ON u.id = comp.usuario_id
            LEFT JOIN cursos c ON comp.curso_id = c.id
            WHERE u.tipo = 'aluno' AND u.ativo = true
            GROUP BY u.id
            ORDER BY u.created_at DESC
        `);

        res.json(alunos);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao gerar relatório de alunos' });
    }
});

app.get('/api/admin/relatorios/pagamentos', authenticateToken('admin'), async (req, res) => {
    try {
        const { inicio, fim } = req.query;
        
        let query = `
            SELECT 
                comp.*,
                u.nome as aluno_nome,
                u.email as aluno_email,
                c.titulo as curso_titulo
            FROM compras comp
            JOIN usuarios u ON comp.usuario_id = u.id
            JOIN cursos c ON comp.curso_id = c.id
            WHERE comp.status = 'aprovado'
        `;
        
        let values = [];
        
        if (inicio && fim) {
            query += ' AND DATE(comp.created_at) BETWEEN ? AND ?';
            values.push(inicio, fim);
        }
        
        query += ' ORDER BY comp.data_pagamento DESC';
        
        const [pagamentos] = await pool.execute(query, values);
        
        res.json(pagamentos);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao gerar relatório de pagamentos' });
    }
});

app.get('/api/admin/relatorios/leads', authenticateToken('admin'), async (req, res) => {
    try {
        const { inicio, fim } = req.query;
        
        let query = 'SELECT * FROM leads WHERE 1=1';
        let values = [];
        
        if (inicio && fim) {
            query += ' AND DATE(created_at) BETWEEN ? AND ?';
            values.push(inicio, fim);
        }
        
        query += ' ORDER BY created_at DESC';
        
        const [leads] = await pool.execute(query, values);
        
        // Estatísticas
        const [totalLeads] = await pool.execute('SELECT COUNT(*) as total FROM leads');
        const [leadsHoje] = await pool.execute(
            'SELECT COUNT(*) as total FROM leads WHERE DATE(created_at) = CURDATE()'
        );
        const [leadsSemana] = await pool.execute(
            'SELECT COUNT(*) as total FROM leads WHERE YEARWEEK(created_at, 1) = YEARWEEK(CURDATE(), 1)'
        );
        
        res.json({
            lista: leads,
            estatisticas: {
                total: totalLeads[0].total,
                hoje: leadsHoje[0].total,
                semana: leadsSemana[0].total
            }
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao gerar relatório de leads' });
    }
});

// Rota de Pagamento (Simulação)
app.post('/api/pagamento/checkout', authenticateToken('aluno'), async (req, res) => {
    try {
        const { curso_id, metodo_pagamento } = req.body;
        const usuario_id = req.user.id;

        // Buscar curso
        const [cursos] = await pool.execute(
            'SELECT id, titulo, valor FROM cursos WHERE id = ? AND ativo = true',
            [curso_id]
        );

        if (cursos.length === 0) {
            return res.status(404).json({ error: 'Curso não encontrado' });
        }

        const curso = cursos[0];

        // Verificar se já possui o curso
        const [comprasExistentes] = await pool.execute(
            'SELECT id FROM compras WHERE usuario_id = ? AND curso_id = ? AND status = "aprovado"',
            [usuario_id, curso_id]
        );

        if (comprasExistentes.length > 0) {
            return res.status(400).json({ error: 'Você já possui este curso' });
        }

        // Criar registro de compra
        const [result] = await pool.execute(
            `INSERT INTO compras 
             (usuario_id, curso_id, valor, status, metodo_pagamento, transacao_id, data_pagamento) 
             VALUES (?, ?, ?, 'aprovado', ?, UUID(), NOW())`,
            [usuario_id, curso_id, curso.valor, metodo_pagamento]
        );

        // Aqui integraria com gateway de pagamento real
        // Por enquanto, simulamos aprovação imediata

        res.json({
            message: 'Pagamento realizado com sucesso',
            compra_id: result.insertId,
            curso: curso.titulo,
            valor: curso.valor
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao processar pagamento' });
    }
});

// Rota para Acesso ao Curso
app.post('/api/cursos/:id/acesso', authenticateToken('aluno'), async (req, res) => {
    try {
        const curso_id = req.params.id;
        const usuario_id = req.user.id;

        // Verificar se usuário tem acesso ao curso
        const [acesso] = await pool.execute(`
            SELECT c.* 
            FROM compras comp
            JOIN cursos c ON comp.curso_id = c.id
            WHERE comp.usuario_id = ? 
            AND comp.curso_id = ? 
            AND comp.status = 'aprovado'
        `, [usuario_id, curso_id]);

        if (acesso.length === 0) {
            return res.status(403).json({ error: 'Acesso negado ao curso' });
        }

        const curso = acesso[0];

        // Registrar acesso
        await pool.execute(
            'INSERT INTO acessos_cursos (usuario_id, curso_id) VALUES (?, ?)',
            [usuario_id, curso_id]
        );

        // Buscar conteúdo do curso
        const [conteudos] = await pool.execute(
            'SELECT * FROM conteudos_curso WHERE curso_id = ? ORDER BY ordem',
            [curso_id]
        );

        res.json({
            curso: {
                id: curso.id,
                titulo: curso.titulo,
                descricao: curso.descricao,
                link_acesso: curso.link_acesso
            },
            conteudos: conteudos
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao acessar curso' });
    }
});

// Iniciar servidor
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
    console.log(`Servidor rodando na porta ${PORT}`);
});

// Configurações adicionais no backend
// backend/package.json (resumo)
/*
{
  "name": "matematica-facil-backend",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "morgan": "^1.10.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.0",
    "mysql2": "^3.3.3",
    "dotenv": "^16.0.3"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  }
}
*/
const helmet = require('helmet');
const morgan = require('morgan');
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const mysql = require('mysql2/promise');
require('dotenv').config();

const app = express();

// Middleware
app.use(helmet());
app.use(cors());
app.use(morgan('dev'));
app.use(express.json());

// Configuração do Banco de Dados
const dbConfig = {
    host: process.env.DB_HOST || 'localhost',
    user: process.env.DB_USER || 'root',
    password: process.env.DB_PASSWORD || '',
    database: process.env.DB_NAME || 'matematica_facil',
    waitForConnections: true,
    connectionLimit: 10,
    queueLimit: 0
};

const pool = mysql.createPool(dbConfig);

// Middleware de Autenticação
const authenticateToken = (requiredRole = null) => {
    return async (req, res, next) => {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];

        if (!token) {
            return res.status(401).json({ error: 'Token não fornecido' });
        }

        try {
            const decoded = jwt.verify(token, process.env.JWT_SECRET || 'secret_key');
            
            // Buscar usuário no banco
            const [users] = await pool.execute(
                'SELECT * FROM usuarios WHERE id = ? AND ativo = true',
                [decoded.userId]
            );

            if (users.length === 0) {
                return res.status(401).json({ error: 'Usuário não encontrado' });
            }

            req.user = users[0];

            // Verificar role se necessário
            if (requiredRole && req.user.tipo !== requiredRole) {
                return res.status(403).json({ error: 'Acesso negado' });
            }

            next();
        } catch (error) {
            return res.status(403).json({ error: 'Token inválido' });
        }
    };
};

// Rotas de Autenticação
app.post('/api/auth/register', async (req, res) => {
    try {
        const { nome, email, senha } = req.body;

        // Verificar se email já existe
        const [existingUsers] = await pool.execute(
            'SELECT id FROM usuarios WHERE email = ?',
            [email]
        );

        if (existingUsers.length > 0) {
            return res.status(400).json({ error: 'Email já cadastrado' });
        }

        // Hash da senha
        const hashedPassword = await bcrypt.hash(senha, 10);

        // Inserir usuário
        const [result] = await pool.execute(
            'INSERT INTO usuarios (nome, email, senha, tipo) VALUES (?, ?, ?, "aluno")',
            [nome, email, hashedPassword]
        );

        // Gerar token JWT
        const token = jwt.sign(
            { userId: result.insertId, email },
            process.env.JWT_SECRET || 'secret_key',
            { expiresIn: '24h' }
        );

        res.status(201).json({
            message: 'Usuário cadastrado com sucesso',
            token,
            user: {
                id: result.insertId,
                nome,
                email,
                tipo: 'aluno'
            }
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao cadastrar usuário' });
    }
});

app.post('/api/auth/login', async (req, res) => {
    try {
        const { email, senha } = req.body;

        // Buscar usuário
        const [users] = await pool.execute(
            'SELECT * FROM usuarios WHERE email = ? AND ativo = true',
            [email]
        );

        if (users.length === 0) {
            return res.status(401).json({ error: 'Credenciais inválidas' });
        }

        const user = users[0];

        // Verificar senha
        const validPassword = await bcrypt.compare(senha, user.senha);
        if (!validPassword) {
            return res.status(401).json({ error: 'Credenciais inválidas' });
        }

        // Gerar token JWT
        const token = jwt.sign(
            { userId: user.id, email: user.email },
            process.env.JWT_SECRET || 'secret_key',
            { expiresIn: '24h' }
        );

        res.json({
            token,
            user: {
                id: user.id,
                nome: user.nome,
                email: user.email,
                tipo: user.tipo,
                foto_url: user.foto_url
            }
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao fazer login' });
    }
});

// Rotas de Cursos (Públicas)
app.get('/api/cursos', async (req, res) => {
    try {
        const [cursos] = await pool.execute(
            'SELECT id, titulo, descricao, valor, imagem_url FROM cursos WHERE ativo = true ORDER BY created_at DESC'
        );
        res.json(cursos);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao buscar cursos' });
    }
});

app.get('/api/cursos/:id', async (req, res) => {
    try {
        const [cursos] = await pool.execute(
            'SELECT id, titulo, descricao, valor, imagem_url FROM cursos WHERE id = ? AND ativo = true',
            [req.params.id]
        );

        if (cursos.length === 0) {
            return res.status(404).json({ error: 'Curso não encontrado' });
        }

        res.json(cursos[0]);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao buscar curso' });
    }
});

// Rotas de Aulas Demo
app.get('/api/aulas-demo', async (req, res) => {
    try {
        const [aulas] = await pool.execute(
            'SELECT id, titulo, descricao, video_url, duracao_minutos FROM aulas_demo WHERE ativo = true ORDER BY ordem'
        );
        res.json(aulas);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao buscar aulas demo' });
    }
});

app.post('/api/leads', async (req, res) => {
    try {
        const { nome, email } = req.body;

        // Verificar se email já existe
        const [existingLeads] = await pool.execute(
            'SELECT id FROM leads WHERE email = ?',
            [email]
        );

        if (existingLeads.length > 0) {
            return res.status(200).json({ message: 'Lead já cadastrado' });
        }

        // Inserir lead
        await pool.execute(
            'INSERT INTO leads (nome, email, origem) VALUES (?, ?, "aula_demo")',
            [nome, email]
        );

        res.status(201).json({ message: 'Lead cadastrado com sucesso' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao cadastrar lead' });
    }
});

// Rotas do Painel Administrativo (Protegidas)
app.get('/api/admin/cursos', authenticateToken('admin'), async (req, res) => {
    try {
        const [cursos] = await pool.execute(
            'SELECT * FROM cursos ORDER BY created_at DESC'
        );
        res.json(cursos);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao buscar cursos' });
    }
});

app.post('/api/admin/cursos', authenticateToken('admin'), async (req, res) => {
    try {
        const { titulo, descricao, valor, link_acesso, senha_acesso, imagem_url } = req.body;

        // Gerar hash da senha de acesso
        const hashedPassword = await bcrypt.hash(senha_acesso, 10);

        const [result] = await pool.execute(
            'INSERT INTO cursos (titulo, descricao, valor, link_acesso, senha_acesso, imagem_url) VALUES (?, ?, ?, ?, ?, ?)',
            [titulo, descricao, valor, link_acesso, hashedPassword, imagem_url]
        );

        res.status(201).json({
            message: 'Curso criado com sucesso',
            id: result.insertId
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao criar curso' });
    }
});

app.put('/api/admin/cursos/:id', authenticateToken('admin'), async (req, res) => {
    try {
        const { titulo, descricao, valor, link_acesso, senha_acesso, imagem_url, ativo } = req.body;
        const cursoId = req.params.id;

        let updateFields = [];
        let values = [];

        if (titulo) { updateFields.push('titulo = ?'); values.push(titulo); }
        if (descricao) { updateFields.push('descricao = ?'); values.push(descricao); }
        if (valor) { updateFields.push('valor = ?'); values.push(valor); }
        if (link_acesso) { updateFields.push('link_acesso = ?'); values.push(link_acesso); }
        if (senha_acesso) {
            const hashedPassword = await bcrypt.hash(senha_acesso, 10);
            updateFields.push('senha_acesso = ?');
            values.push(hashedPassword);
        }
        if (imagem_url) { updateFields.push('imagem_url = ?'); values.push(imagem_url); }
        if (ativo !== undefined) { updateFields.push('ativo = ?'); values.push(ativo); }

        values.push(cursoId);

        if (updateFields.length === 0) {
            return res.status(400).json({ error: 'Nenhum campo para atualizar' });
        }

        const query = `UPDATE cursos SET ${updateFields.join(', ')} WHERE id = ?`;
        
        await pool.execute(query, values);

        res.json({ message: 'Curso atualizado com sucesso' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao atualizar curso' });
    }
});

app.delete('/api/admin/cursos/:id', authenticateToken('admin'), async (req, res) => {
    try {
        await pool.execute('DELETE FROM cursos WHERE id = ?', [req.params.id]);
        res.json({ message: 'Curso excluído com sucesso' });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao excluir curso' });
    }
});

// Relatórios Administrativos
app.get('/api/admin/relatorios/alunos', authenticateToken('admin'), async (req, res) => {
    try {
        const [alunos] = await pool.execute(`
            SELECT 
                u.id,
                u.nome,
                u.email,
                COUNT(DISTINCT c.id) as total_cursos,
                COUNT(DISTINCT comp.id) as total_compras,
                SUM(CASE WHEN comp.status = 'aprovado' THEN comp.valor ELSE 0 END) as total_gasto,
                MAX(comp.created_at) as ultima_compra
            FROM usuarios u
            LEFT JOIN compras comp ON u.id = comp.usuario_id
            LEFT JOIN cursos c ON comp.curso_id = c.id
            WHERE u.tipo = 'aluno' AND u.ativo = true
            GROUP BY u.id
            ORDER BY u.created_at DESC
        `);

        res.json(alunos);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao gerar relatório de alunos' });
    }
});

app.get('/api/admin/relatorios/pagamentos', authenticateToken('admin'), async (req, res) => {
    try {
        const { inicio, fim } = req.query;
        
        let query = `
            SELECT 
                comp.*,
                u.nome as aluno_nome,
                u.email as aluno_email,
                c.titulo as curso_titulo
            FROM compras comp
            JOIN usuarios u ON comp.usuario_id = u.id
            JOIN cursos c ON comp.curso_id = c.id
            WHERE comp.status = 'aprovado'
        `;
        
        let values = [];
        
        if (inicio && fim) {
            query += ' AND DATE(comp.created_at) BETWEEN ? AND ?';
            values.push(inicio, fim);
        }
        
        query += ' ORDER BY comp.data_pagamento DESC';
        
        const [pagamentos] = await pool.execute(query, values);
        
        res.json(pagamentos);
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao gerar relatório de pagamentos' });
    }
});

app.get('/api/admin/relatorios/leads', authenticateToken('admin'), async (req, res) => {
    try {
        const { inicio, fim } = req.query;
        
        let query = 'SELECT * FROM leads WHERE 1=1';
        let values = [];
        
        if (inicio && fim) {
            query += ' AND DATE(created_at) BETWEEN ? AND ?';
            values.push(inicio, fim);
        }
        
        query += ' ORDER BY created_at DESC';
        
        const [leads] = await pool.execute(query, values);
        
        // Estatísticas
        const [totalLeads] = await pool.execute('SELECT COUNT(*) as total FROM leads');
        const [leadsHoje] = await pool.execute(
            'SELECT COUNT(*) as total FROM leads WHERE DATE(created_at) = CURDATE()'
        );
        const [leadsSemana] = await pool.execute(
            'SELECT COUNT(*) as total FROM leads WHERE YEARWEEK(created_at, 1) = YEARWEEK(CURDATE(), 1)'
        );
        
        res.json({
            lista: leads,
            estatisticas: {
                total: totalLeads[0].total,
                hoje: leadsHoje[0].total,
                semana: leadsSemana[0].total
            }
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao gerar relatório de leads' });
    }
});

// Rota de Pagamento (Simulação)
app.post('/api/pagamento/checkout', authenticateToken('aluno'), async (req, res) => {
    try {
        const { curso_id, metodo_pagamento } = req.body;
        const usuario_id = req.user.id;

        // Buscar curso
        const [cursos] = await pool.execute(
            'SELECT id, titulo, valor FROM cursos WHERE id = ? AND ativo = true',
            [curso_id]
        );

        if (cursos.length === 0) {
            return res.status(404).json({ error: 'Curso não encontrado' });
        }

        const curso = cursos[0];

        // Verificar se já possui o curso
        const [comprasExistentes] = await pool.execute(
            'SELECT id FROM compras WHERE usuario_id = ? AND curso_id = ? AND status = "aprovado"',
            [usuario_id, curso_id]
        );

        if (comprasExistentes.length > 0) {
            return res.status(400).json({ error: 'Você já possui este curso' });
        }

        // Criar registro de compra
        const [result] = await pool.execute(
            `INSERT INTO compras 
             (usuario_id, curso_id, valor, status, metodo_pagamento, transacao_id, data_pagamento) 
             VALUES (?, ?, ?, 'aprovado', ?, UUID(), NOW())`,
            [usuario_id, curso_id, curso.valor, metodo_pagamento]
        );

        // Aqui integraria com gateway de pagamento real
        // Por enquanto, simulamos aprovação imediata

        res.json({
            message: 'Pagamento realizado com sucesso',
            compra_id: result.insertId,
            curso: curso.titulo,
            valor: curso.valor
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao processar pagamento' });
    }
});

// Rota para Acesso ao Curso
app.post('/api/cursos/:id/acesso', authenticateToken('aluno'), async (req, res) => {
    try {
        const curso_id = req.params.id;
        const usuario_id = req.user.id;

        // Verificar se usuário tem acesso ao curso
        const [acesso] = await pool.execute(`
            SELECT c.* 
            FROM compras comp
            JOIN cursos c ON comp.curso_id = c.id
            WHERE comp.usuario_id = ? 
            AND comp.curso_id = ? 
            AND comp.status = 'aprovado'
        `, [usuario_id, curso_id]);

        if (acesso.length === 0) {
            return res.status(403).json({ error: 'Acesso negado ao curso' });
        }

        const curso = acesso[0];

        // Registrar acesso
        await pool.execute(
            'INSERT INTO acessos_cursos (usuario_id, curso_id) VALUES (?, ?)',
            [usuario_id, curso_id]
        );

        // Buscar conteúdo do curso
        const [conteudos] = await pool.execute(
            'SELECT * FROM conteudos_curso WHERE curso_id = ? ORDER BY ordem',
            [curso_id]
        );

        res.json({
            curso: {
                id: curso.id,
                titulo: curso.titulo,
                descricao: curso.descricao,
                link_acesso: curso.link_acesso
            },
            conteudos: conteudos
        });
    } catch (error) {
        console.error(error);
        res.status(500).json({ error: 'Erro ao acessar curso' });
    }
});

// Iniciar servidor
const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
    console.log(`Servidor rodando na porta ${PORT}`);
});

// Configurações adicionais no backend
// backend/package.json (resumo)
/*
{
  "name": "matematica-facil-backend",
  "version": "1.0.0",
  "dependencies": {
    "express": "^4.18.2",
    "cors": "^2.8.5",
    "helmet": "^7.0.0",
    "morgan": "^1.10.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.0",
    "mysql2": "^3.3.3",
    "dotenv": "^16.0.3"
  },
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  }
}
*/